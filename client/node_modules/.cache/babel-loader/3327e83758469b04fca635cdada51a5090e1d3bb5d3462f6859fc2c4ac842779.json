{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\treev\\\\mindmap-app\\\\client\\\\src\\\\pages\\\\ExportMarkdown.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport { useParams } from 'react-router-dom';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SERVER_URL = process.env.REACT_APP_SERVER_URL || 'http://localhost:4000';\n// 深さ（7階層）を超えたら無視する\nconst MAX_DEPTH = 7;\n\n/**\r\n * ExportMarkdown:\r\n * マインドマップのデータ(nodes, edges)から\r\n * - ルートノード判定\r\n * - ツリー構築 & 番号付け\r\n * - Markdown形式への統合出力\r\n * - 固定ヘッダー + コピー機能\r\n */\nfunction ExportMarkdown() {\n  _s();\n  // URLパラメータから mindmapId を取得\n  const {\n    mindmapId\n  } = useParams();\n  const [mindmap, setMindmap] = useState(null);\n  const [markdownText, setMarkdownText] = useState('');\n  const [copyMode, setCopyMode] = useState(false);\n  useEffect(() => {\n    fetchData();\n  }, [mindmapId]);\n\n  // サーバーからマインドマップ取得\n  const fetchData = async () => {\n    try {\n      const res = await axios.get(`${SERVER_URL}/api/mindmaps/${mindmapId}`);\n      setMindmap(res.data);\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  // mindmap 取得後に番号付け & Markdown生成\n  useEffect(() => {\n    if (!mindmap) return;\n    const numberedNodes = buildNumberedTree(mindmap);\n    const md = convertToMarkdown(numberedNodes);\n    setMarkdownText(md);\n  }, [mindmap]);\n\n  /**\r\n   * ツリー構築 & 番号付け\r\n   * 1) ルートノード: インバウンドエッジが無いノード\r\n   * 2) 子ノード: edges で繋がっている中から \"from === parentId\" のものを作成順に探す\r\n   * 3) 再帰的に \"parentNumber.childIndex\" 形式で番号付け\r\n   * 4) 深さが 7 超える場合は無視\r\n   */\n  const buildNumberedTree = mapData => {\n    const {\n      nodes,\n      edges\n    } = mapData;\n    if (!nodes || nodes.length === 0) return [];\n\n    // ノードID -> インバウンド数\n    const inboundCountMap = {};\n    nodes.forEach(node => {\n      inboundCountMap[node.nodeId] = 0;\n    });\n    edges === null || edges === void 0 ? void 0 : edges.forEach(edge => {\n      if (inboundCountMap[edge.to] != null) {\n        inboundCountMap[edge.to]++;\n      }\n    });\n\n    // ルートノード判定 (inboundCount=0 のノードが候補)\n    const rootNodes = nodes.filter(n => inboundCountMap[n.nodeId] === 0);\n    // 複数ある場合は先頭をルートとするなどルールを決める\n    const rootNode = rootNodes[0] || nodes[0];\n    if (!rootNode) return [];\n\n    // ノードID -> ノードオブジェクト\n    const nodeMap = {};\n    nodes.forEach(nd => {\n      nodeMap[nd.nodeId] = nd;\n    });\n\n    // 子リストを作る: 親 -> [子ノードID,...] (作成順に)\n    // 作成順 = nodes の並び順と解釈する\n    const childrenMap = {};\n    nodes.forEach(nd => {\n      childrenMap[nd.nodeId] = [];\n    });\n    edges === null || edges === void 0 ? void 0 : edges.forEach(edge => {\n      if (childrenMap[edge.from]) {\n        childrenMap[edge.from].push(edge.to);\n      }\n    });\n\n    // childrenMap[ parentId ] をノード作成順にソート\n    Object.keys(childrenMap).forEach(key => {\n      childrenMap[key].sort((a, b) => {\n        const idxA = nodes.findIndex(n => n.nodeId === a);\n        const idxB = nodes.findIndex(n => n.nodeId === b);\n        return idxA - idxB;\n      });\n    });\n\n    // 再帰的に番号を振りながらツリーをたどる\n    const result = [];\n    const dfs = (nodeId, numbering) => {\n      const depth = numbering.split('.').length;\n      if (depth > MAX_DEPTH) {\n        // 深さが7を超えたら無視（このノード含め枝下も無視）\n        return;\n      }\n      const nodeObj = nodeMap[nodeId];\n      if (!nodeObj) return;\n\n      // このノードを出力リストに加える\n      result.push({\n        numbering,\n        text: nodeObj.text || ''\n      });\n\n      // 子ノードを巡回\n      const childs = childrenMap[nodeId] || [];\n      childs.forEach((childId, index) => {\n        const newNumber = `${numbering}.${index + 1}`;\n        dfs(childId, newNumber);\n      });\n    };\n\n    // ルートノードを \"1\" で開始\n    dfs(rootNode.nodeId, '1');\n    return result; // [{ numbering: \"1\", text: \"ルートの内容\" }, { numbering: \"1.1\", text: \"...\"}... ]\n  };\n\n  /**\r\n   * 番号付きツリーを Markdown の文字列に変換\r\n   * 見出しレベルは numbering の \"ドット区切りの数\"。\r\n   * 例: numbering=\"1.2\" => level=2 => \"## 1.2\"\r\n   */\n  const convertToMarkdown = numberedNodes => {\n    let md = '';\n    numberedNodes.forEach(item => {\n      const parts = item.numbering.split('.');\n      const level = parts.length; // ドットがある数 = 深さ\n      // 先頭行: #{レベル分} {numbering}\n      md += `${'#'.repeat(level)} ${item.numbering}\\n`;\n      // 次の行にノード内容\n      md += (item.text || '(no content)') + '\\n\\n';\n    });\n    return md.trim();\n  };\n\n  /**\r\n   * 「コピーモード」の挙動:\r\n   * - copyMode = true の場合、Markdown表示行で先頭が '#' の行に hoverすると強調\r\n   * - クリックで「該当見出し行～次の見出し行の直前」までをクリップボードにコピー\r\n   */\n  const handleCopySection = (startIndex, lines) => {\n    // 次の「#で始まる行」または文末 までをコピー対象にする\n    let endIndex = lines.length;\n    for (let i = startIndex + 1; i < lines.length; i++) {\n      if (lines[i].startsWith('#')) {\n        endIndex = i;\n        break;\n      }\n    }\n    const sectionText = lines.slice(startIndex, endIndex).join('\\n');\n    navigator.clipboard.writeText(sectionText).then(() => {\n      alert('クリップボードにコピーしました');\n    });\n  };\n\n  /**\r\n   * Markdownを行分割して表示し、コピー機能を実装\r\n   */\n  const renderMarkdownWithCopy = md => {\n    const lines = md.split('\\n');\n    return lines.map((line, i) => {\n      const isHeading = line.startsWith('#');\n      if (!copyMode) {\n        // 通常モード\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          children: line\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 182,\n          columnNumber: 16\n        }, this);\n      } else {\n        // コピーモード: 見出し行に hover/click のハイライト・コピー動作を付与\n        if (isHeading) {\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            style: {\n              cursor: 'pointer'\n            },\n            onMouseOver: e => {\n              e.currentTarget.style.backgroundColor = '#ffffa0'; // hover色\n            },\n            onMouseOut: e => {\n              e.currentTarget.style.backgroundColor = 'transparent';\n            },\n            onClick: () => handleCopySection(i, lines),\n            children: line\n          }, i, false, {\n            fileName: _jsxFileName,\n            lineNumber: 187,\n            columnNumber: 13\n          }, this);\n        } else {\n          return /*#__PURE__*/_jsxDEV(\"div\", {\n            children: line\n          }, i, false, {\n            fileName: _jsxFileName,\n            lineNumber: 202,\n            columnNumber: 18\n          }, this);\n        }\n      }\n    });\n  };\n  if (!mindmap) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: \"\\u8AAD\\u307F\\u8FBC\\u307F\\u4E2D...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 209,\n      columnNumber: 12\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100vh',\n      margin: 0\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: 50,\n        background: '#ddd',\n        display: 'flex',\n        alignItems: 'center',\n        padding: '0 20px',\n        boxSizing: 'border-box',\n        zIndex: 10\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        style: {\n          marginRight: 20\n        },\n        children: [mindmap.title, \" - Export\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 230,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setCopyMode(!copyMode),\n        children: copyMode ? 'コピーモードOFF' : 'コピーモードON'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 231,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 215,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginTop: 60,\n        padding: '0 20px'\n      },\n      children: renderMarkdownWithCopy(markdownText)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 237,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 213,\n    columnNumber: 5\n  }, this);\n}\n_s(ExportMarkdown, \"mbEWxCKJNfOJ6QLJ30LjusplU1Y=\", false, function () {\n  return [useParams];\n});\n_c = ExportMarkdown;\nexport default ExportMarkdown;\nvar _c;\n$RefreshReg$(_c, \"ExportMarkdown\");","map":{"version":3,"names":["React","useState","useEffect","axios","useParams","jsxDEV","_jsxDEV","SERVER_URL","process","env","REACT_APP_SERVER_URL","MAX_DEPTH","ExportMarkdown","_s","mindmapId","mindmap","setMindmap","markdownText","setMarkdownText","copyMode","setCopyMode","fetchData","res","get","data","err","console","error","numberedNodes","buildNumberedTree","md","convertToMarkdown","mapData","nodes","edges","length","inboundCountMap","forEach","node","nodeId","edge","to","rootNodes","filter","n","rootNode","nodeMap","nd","childrenMap","from","push","Object","keys","key","sort","a","b","idxA","findIndex","idxB","result","dfs","numbering","depth","split","nodeObj","text","childs","childId","index","newNumber","item","parts","level","repeat","trim","handleCopySection","startIndex","lines","endIndex","i","startsWith","sectionText","slice","join","navigator","clipboard","writeText","then","alert","renderMarkdownWithCopy","map","line","isHeading","children","fileName","_jsxFileName","lineNumber","columnNumber","style","cursor","onMouseOver","e","currentTarget","backgroundColor","onMouseOut","onClick","position","width","height","margin","top","left","background","display","alignItems","padding","boxSizing","zIndex","marginRight","title","marginTop","_c","$RefreshReg$"],"sources":["C:/Users/treev/mindmap-app/client/src/pages/ExportMarkdown.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport axios from 'axios';\r\nimport { useParams } from 'react-router-dom';\r\n\r\nconst SERVER_URL = process.env.REACT_APP_SERVER_URL || 'http://localhost:4000';\r\n// 深さ（7階層）を超えたら無視する\r\nconst MAX_DEPTH = 7;\r\n\r\n/**\r\n * ExportMarkdown:\r\n * マインドマップのデータ(nodes, edges)から\r\n * - ルートノード判定\r\n * - ツリー構築 & 番号付け\r\n * - Markdown形式への統合出力\r\n * - 固定ヘッダー + コピー機能\r\n */\r\nfunction ExportMarkdown() {\r\n  // URLパラメータから mindmapId を取得\r\n  const { mindmapId } = useParams();\r\n  const [mindmap, setMindmap] = useState(null);\r\n  const [markdownText, setMarkdownText] = useState('');\r\n  const [copyMode, setCopyMode] = useState(false);\r\n\r\n  useEffect(() => {\r\n    fetchData();\r\n  }, [mindmapId]);\r\n\r\n  // サーバーからマインドマップ取得\r\n  const fetchData = async () => {\r\n    try {\r\n      const res = await axios.get(`${SERVER_URL}/api/mindmaps/${mindmapId}`);\r\n      setMindmap(res.data);\r\n    } catch (err) {\r\n      console.error(err);\r\n    }\r\n  };\r\n\r\n  // mindmap 取得後に番号付け & Markdown生成\r\n  useEffect(() => {\r\n    if (!mindmap) return;\r\n    const numberedNodes = buildNumberedTree(mindmap);\r\n    const md = convertToMarkdown(numberedNodes);\r\n    setMarkdownText(md);\r\n  }, [mindmap]);\r\n\r\n  /**\r\n   * ツリー構築 & 番号付け\r\n   * 1) ルートノード: インバウンドエッジが無いノード\r\n   * 2) 子ノード: edges で繋がっている中から \"from === parentId\" のものを作成順に探す\r\n   * 3) 再帰的に \"parentNumber.childIndex\" 形式で番号付け\r\n   * 4) 深さが 7 超える場合は無視\r\n   */\r\n  const buildNumberedTree = (mapData) => {\r\n    const { nodes, edges } = mapData;\r\n    if (!nodes || nodes.length === 0) return [];\r\n\r\n    // ノードID -> インバウンド数\r\n    const inboundCountMap = {};\r\n    nodes.forEach((node) => {\r\n      inboundCountMap[node.nodeId] = 0;\r\n    });\r\n    edges?.forEach((edge) => {\r\n      if (inboundCountMap[edge.to] != null) {\r\n        inboundCountMap[edge.to]++;\r\n      }\r\n    });\r\n\r\n    // ルートノード判定 (inboundCount=0 のノードが候補)\r\n    const rootNodes = nodes.filter((n) => inboundCountMap[n.nodeId] === 0);\r\n    // 複数ある場合は先頭をルートとするなどルールを決める\r\n    const rootNode = rootNodes[0] || nodes[0];\r\n\r\n    if (!rootNode) return [];\r\n\r\n    // ノードID -> ノードオブジェクト\r\n    const nodeMap = {};\r\n    nodes.forEach((nd) => {\r\n      nodeMap[nd.nodeId] = nd;\r\n    });\r\n\r\n    // 子リストを作る: 親 -> [子ノードID,...] (作成順に)\r\n    // 作成順 = nodes の並び順と解釈する\r\n    const childrenMap = {};\r\n    nodes.forEach((nd) => {\r\n      childrenMap[nd.nodeId] = [];\r\n    });\r\n    edges?.forEach((edge) => {\r\n      if (childrenMap[edge.from]) {\r\n        childrenMap[edge.from].push(edge.to);\r\n      }\r\n    });\r\n\r\n    // childrenMap[ parentId ] をノード作成順にソート\r\n    Object.keys(childrenMap).forEach((key) => {\r\n      childrenMap[key].sort((a, b) => {\r\n        const idxA = nodes.findIndex((n) => n.nodeId === a);\r\n        const idxB = nodes.findIndex((n) => n.nodeId === b);\r\n        return idxA - idxB;\r\n      });\r\n    });\r\n\r\n    // 再帰的に番号を振りながらツリーをたどる\r\n    const result = [];\r\n\r\n    const dfs = (nodeId, numbering) => {\r\n      const depth = numbering.split('.').length;\r\n      if (depth > MAX_DEPTH) {\r\n        // 深さが7を超えたら無視（このノード含め枝下も無視）\r\n        return;\r\n      }\r\n\r\n      const nodeObj = nodeMap[nodeId];\r\n      if (!nodeObj) return;\r\n\r\n      // このノードを出力リストに加える\r\n      result.push({\r\n        numbering,\r\n        text: nodeObj.text || ''\r\n      });\r\n\r\n      // 子ノードを巡回\r\n      const childs = childrenMap[nodeId] || [];\r\n      childs.forEach((childId, index) => {\r\n        const newNumber = `${numbering}.${index + 1}`;\r\n        dfs(childId, newNumber);\r\n      });\r\n    };\r\n\r\n    // ルートノードを \"1\" で開始\r\n    dfs(rootNode.nodeId, '1');\r\n\r\n    return result; // [{ numbering: \"1\", text: \"ルートの内容\" }, { numbering: \"1.1\", text: \"...\"}... ]\r\n  };\r\n\r\n  /**\r\n   * 番号付きツリーを Markdown の文字列に変換\r\n   * 見出しレベルは numbering の \"ドット区切りの数\"。\r\n   * 例: numbering=\"1.2\" => level=2 => \"## 1.2\"\r\n   */\r\n  const convertToMarkdown = (numberedNodes) => {\r\n    let md = '';\r\n    numberedNodes.forEach((item) => {\r\n      const parts = item.numbering.split('.');\r\n      const level = parts.length; // ドットがある数 = 深さ\r\n      // 先頭行: #{レベル分} {numbering}\r\n      md += `${'#'.repeat(level)} ${item.numbering}\\n`;\r\n      // 次の行にノード内容\r\n      md += (item.text || '(no content)') + '\\n\\n';\r\n    });\r\n    return md.trim();\r\n  };\r\n\r\n  /**\r\n   * 「コピーモード」の挙動:\r\n   * - copyMode = true の場合、Markdown表示行で先頭が '#' の行に hoverすると強調\r\n   * - クリックで「該当見出し行～次の見出し行の直前」までをクリップボードにコピー\r\n   */\r\n  const handleCopySection = (startIndex, lines) => {\r\n    // 次の「#で始まる行」または文末 までをコピー対象にする\r\n    let endIndex = lines.length;\r\n    for (let i = startIndex + 1; i < lines.length; i++) {\r\n      if (lines[i].startsWith('#')) {\r\n        endIndex = i;\r\n        break;\r\n      }\r\n    }\r\n    const sectionText = lines.slice(startIndex, endIndex).join('\\n');\r\n    navigator.clipboard.writeText(sectionText).then(() => {\r\n      alert('クリップボードにコピーしました');\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Markdownを行分割して表示し、コピー機能を実装\r\n   */\r\n  const renderMarkdownWithCopy = (md) => {\r\n    const lines = md.split('\\n');\r\n    return lines.map((line, i) => {\r\n      const isHeading = line.startsWith('#');\r\n      if (!copyMode) {\r\n        // 通常モード\r\n        return <div key={i}>{line}</div>;\r\n      } else {\r\n        // コピーモード: 見出し行に hover/click のハイライト・コピー動作を付与\r\n        if (isHeading) {\r\n          return (\r\n            <div\r\n              key={i}\r\n              style={{ cursor: 'pointer' }}\r\n              onMouseOver={(e) => {\r\n                e.currentTarget.style.backgroundColor = '#ffffa0'; // hover色\r\n              }}\r\n              onMouseOut={(e) => {\r\n                e.currentTarget.style.backgroundColor = 'transparent';\r\n              }}\r\n              onClick={() => handleCopySection(i, lines)}\r\n            >\r\n              {line}\r\n            </div>\r\n          );\r\n        } else {\r\n          return <div key={i}>{line}</div>;\r\n        }\r\n      }\r\n    });\r\n  };\r\n\r\n  if (!mindmap) {\r\n    return <div>読み込み中...</div>;\r\n  }\r\n\r\n  return (\r\n    <div style={{ position: 'relative', width: '100%', height: '100vh', margin: 0 }}>\r\n      {/* 固定ヘッダー */}\r\n      <div\r\n        style={{\r\n          position: 'fixed',\r\n          top: 0,\r\n          left: 0,\r\n          width: '100%',\r\n          height: 50,\r\n          background: '#ddd',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          padding: '0 20px',\r\n          boxSizing: 'border-box',\r\n          zIndex: 10\r\n        }}\r\n      >\r\n        <h3 style={{ marginRight: 20 }}>{mindmap.title} - Export</h3>\r\n        <button onClick={() => setCopyMode(!copyMode)}>\r\n          {copyMode ? 'コピーモードOFF' : 'コピーモードON'}\r\n        </button>\r\n      </div>\r\n\r\n      {/* Markdown表示部 (スクロール可能) */}\r\n      <div style={{ marginTop: 60, padding: '0 20px' }}>\r\n        {renderMarkdownWithCopy(markdownText)}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default ExportMarkdown;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}