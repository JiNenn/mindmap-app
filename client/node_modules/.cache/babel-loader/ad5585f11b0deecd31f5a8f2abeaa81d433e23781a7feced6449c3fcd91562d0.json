{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\treev\\\\mindmap-app\\\\client\\\\src\\\\pages\\\\ExportMarkdown.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport axios from 'axios';\nimport { useParams } from 'react-router-dom';\nimport { marked } from 'marked';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst SERVER_URL = process.env.REACT_APP_SERVER_URL || 'http://localhost:4000';\n// 深さ（7階層）を超えたら無視する\nconst MAX_DEPTH = 7;\n\n/**\r\n * ExportMarkdown:\r\n * マインドマップのデータ(nodes, edges)から\r\n * - ルートノード判定\r\n * - ツリー構築 & 番号付け\r\n * - Markdown形式への統合出力\r\n * - 固定ヘッダー + コピー機能\r\n */\nfunction ExportMarkdown() {\n  _s();\n  // URL パラメータから mindmapId を取得\n  const {\n    mindmapId\n  } = useParams();\n  const [mindmap, setMindmap] = useState(null);\n  const [markdownText, setMarkdownText] = useState('');\n  const [copyMode, setCopyMode] = useState(false);\n  useEffect(() => {\n    fetchData();\n  }, [mindmapId]);\n\n  // サーバーからマインドマップ取得\n  const fetchData = async () => {\n    try {\n      const res = await axios.get(`${SERVER_URL}/api/mindmaps/${mindmapId}`);\n      setMindmap(res.data);\n    } catch (err) {\n      console.error(err);\n    }\n  };\n\n  // mindmap 取得後に番号付け & Markdown生成\n  useEffect(() => {\n    if (!mindmap) return;\n    const numberedNodes = buildNumberedTree(mindmap);\n    const md = convertToMarkdown(numberedNodes);\n    setMarkdownText(md);\n  }, [mindmap]);\n\n  /**\r\n   * ツリー構築 & 番号付け\r\n   * 1) ルートノード: インバウンドエッジが無いノード\r\n   * 2) 子ノード: edges で繋がっている中から \"from === parentId\" のものを作成順に探す\r\n   * 3) 再帰的に \"parentNumber.childIndex\" 形式で番号付け\r\n   * 4) 深さが 7 超える場合は無視\r\n   */\n  const buildNumberedTree = mapData => {\n    const {\n      nodes,\n      edges\n    } = mapData;\n    if (!nodes || nodes.length === 0) return [];\n\n    // ノードID -> インバウンド数\n    const inboundCountMap = {};\n    nodes.forEach(node => {\n      inboundCountMap[node.nodeId] = 0;\n    });\n    edges === null || edges === void 0 ? void 0 : edges.forEach(edge => {\n      if (inboundCountMap[edge.to] != null) {\n        inboundCountMap[edge.to]++;\n      }\n    });\n\n    // ルートノード判定 (inboundCount=0 のノードが候補)\n    const rootNodes = nodes.filter(n => inboundCountMap[n.nodeId] === 0);\n    // 複数ある場合は先頭をルートとする\n    const rootNode = rootNodes[0] || nodes[0];\n    if (!rootNode) return [];\n\n    // ノードID -> ノードオブジェクト\n    const nodeMap = {};\n    nodes.forEach(nd => {\n      nodeMap[nd.nodeId] = nd;\n    });\n\n    // 親 -> 子ノードID のマップ（作成順に）\n    const childrenMap = {};\n    nodes.forEach(nd => {\n      childrenMap[nd.nodeId] = [];\n    });\n    edges === null || edges === void 0 ? void 0 : edges.forEach(edge => {\n      if (childrenMap[edge.from]) {\n        childrenMap[edge.from].push(edge.to);\n      }\n    });\n    // 作成順にソート（nodes 配列の並び順で）\n    Object.keys(childrenMap).forEach(key => {\n      childrenMap[key].sort((a, b) => {\n        const idxA = nodes.findIndex(n => n.nodeId === a);\n        const idxB = nodes.findIndex(n => n.nodeId === b);\n        return idxA - idxB;\n      });\n    });\n\n    // 再帰的に番号を振りながらツリーをたどる\n    const result = [];\n    const dfs = (nodeId, numbering) => {\n      const depth = numbering.split('.').length;\n      if (depth > MAX_DEPTH) return;\n      const nodeObj = nodeMap[nodeId];\n      if (!nodeObj) return;\n      result.push({\n        numbering,\n        text: nodeObj.text || ''\n      });\n      const childs = childrenMap[nodeId] || [];\n      childs.forEach((childId, index) => {\n        const newNumber = `${numbering}.${index + 1}`;\n        dfs(childId, newNumber);\n      });\n    };\n    // ルートを \"1\" で開始\n    dfs(rootNode.nodeId, '1');\n    return result;\n  };\n\n  /**\r\n   * 番号付きツリーを Markdown の文字列に変換\r\n   * 見出しレベルは numbering のドット区切りの数\r\n   */\n  const convertToMarkdown = numberedNodes => {\n    let md = '';\n    numberedNodes.forEach(item => {\n      const parts = item.numbering.split('.');\n      const level = parts.length;\n      md += `${'#'.repeat(level)} ${item.numbering}\\n`;\n      md += `${item.text}\\n\\n`;\n    });\n    return md.trim();\n  };\n\n  /**\r\n   * 「コピーモード」の挙動:\r\n   * セクション単位で（見出し行から次の見出し直前まで）hover した際に背景色を変え、\r\n   * クリックでそのセクション全体の Markdown テキストをクリップボードにコピーする\r\n   */\n  const handleCopySection = sectionText => {\n    navigator.clipboard.writeText(sectionText).then(() => {\n      alert('クリップボードにコピーしました');\n    });\n  };\n\n  /**\r\n   * Markdown テキストをセクションに分割し、レンダリング（renderCopy モードの場合はセクション全体に\r\n   * hover/click イベントを付与）\r\n   */\n  const renderMarkdownWithCopy = md => {\n    const lines = md.split('\\n');\n    const sections = [];\n    let currentSection = [];\n    lines.forEach(line => {\n      if (line.startsWith('#')) {\n        if (currentSection.length > 0) {\n          sections.push(currentSection);\n        }\n        currentSection = [line];\n      } else {\n        currentSection.push(line);\n      }\n    });\n    if (currentSection.length > 0) {\n      sections.push(currentSection);\n    }\n    return sections.map((sectionLines, idx) => {\n      const sectionText = sectionLines.join('\\n');\n      if (!copyMode) {\n        // 通常はレンダリング済みの HTML として表示（Markdownが解釈される）\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          dangerouslySetInnerHTML: {\n            __html: marked.parse(sectionText, {\n              breaks: true\n            })\n          }\n        }, idx, false, {\n          fileName: _jsxFileName,\n          lineNumber: 174,\n          columnNumber: 11\n        }, this);\n      } else {\n        // コピーモード：セクション全体に hover/click イベントを付与\n        return /*#__PURE__*/_jsxDEV(\"div\", {\n          style: {\n            cursor: 'pointer'\n          },\n          onMouseOver: e => {\n            e.currentTarget.style.backgroundColor = '#ffffa0';\n          },\n          onMouseOut: e => {\n            e.currentTarget.style.backgroundColor = 'transparent';\n          },\n          onClick: () => handleCopySection(sectionText),\n          dangerouslySetInnerHTML: {\n            __html: marked.parse(sectionText, {\n              breaks: true\n            })\n          }\n        }, idx, false, {\n          fileName: _jsxFileName,\n          lineNumber: 182,\n          columnNumber: 11\n        }, this);\n      }\n    });\n  };\n  if (!mindmap) {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      children: \"\\u8AAD\\u307F\\u8FBC\\u307F\\u4E2D...\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 200,\n      columnNumber: 12\n    }, this);\n  }\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    style: {\n      position: 'relative',\n      width: '100%',\n      height: '100vh',\n      margin: 0\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        width: '100%',\n        height: 50,\n        background: '#ddd',\n        display: 'flex',\n        alignItems: 'center',\n        padding: '0 20px',\n        boxSizing: 'border-box',\n        zIndex: 10\n      },\n      children: [/*#__PURE__*/_jsxDEV(\"h3\", {\n        style: {\n          marginRight: 20\n        },\n        children: [mindmap.title, \" - Export\"]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 221,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        onClick: () => setCopyMode(!copyMode),\n        children: copyMode ? 'コピーモードOFF' : 'コピーモードON'\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 222,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 206,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n      style: {\n        marginTop: 60,\n        padding: '0 20px'\n      },\n      children: renderMarkdownWithCopy(markdownText)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 228,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 204,\n    columnNumber: 5\n  }, this);\n}\n_s(ExportMarkdown, \"mbEWxCKJNfOJ6QLJ30LjusplU1Y=\", false, function () {\n  return [useParams];\n});\n_c = ExportMarkdown;\nexport default ExportMarkdown;\nvar _c;\n$RefreshReg$(_c, \"ExportMarkdown\");","map":{"version":3,"names":["React","useState","useEffect","axios","useParams","marked","jsxDEV","_jsxDEV","SERVER_URL","process","env","REACT_APP_SERVER_URL","MAX_DEPTH","ExportMarkdown","_s","mindmapId","mindmap","setMindmap","markdownText","setMarkdownText","copyMode","setCopyMode","fetchData","res","get","data","err","console","error","numberedNodes","buildNumberedTree","md","convertToMarkdown","mapData","nodes","edges","length","inboundCountMap","forEach","node","nodeId","edge","to","rootNodes","filter","n","rootNode","nodeMap","nd","childrenMap","from","push","Object","keys","key","sort","a","b","idxA","findIndex","idxB","result","dfs","numbering","depth","split","nodeObj","text","childs","childId","index","newNumber","item","parts","level","repeat","trim","handleCopySection","sectionText","navigator","clipboard","writeText","then","alert","renderMarkdownWithCopy","lines","sections","currentSection","line","startsWith","map","sectionLines","idx","join","dangerouslySetInnerHTML","__html","parse","breaks","fileName","_jsxFileName","lineNumber","columnNumber","style","cursor","onMouseOver","e","currentTarget","backgroundColor","onMouseOut","onClick","children","position","width","height","margin","top","left","background","display","alignItems","padding","boxSizing","zIndex","marginRight","title","marginTop","_c","$RefreshReg$"],"sources":["C:/Users/treev/mindmap-app/client/src/pages/ExportMarkdown.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\r\nimport axios from 'axios';\r\nimport { useParams } from 'react-router-dom';\r\nimport { marked } from 'marked';\r\n\r\nconst SERVER_URL = process.env.REACT_APP_SERVER_URL || 'http://localhost:4000';\r\n// 深さ（7階層）を超えたら無視する\r\nconst MAX_DEPTH = 7;\r\n\r\n/**\r\n * ExportMarkdown:\r\n * マインドマップのデータ(nodes, edges)から\r\n * - ルートノード判定\r\n * - ツリー構築 & 番号付け\r\n * - Markdown形式への統合出力\r\n * - 固定ヘッダー + コピー機能\r\n */\r\nfunction ExportMarkdown() {\r\n  // URL パラメータから mindmapId を取得\r\n  const { mindmapId } = useParams();\r\n  const [mindmap, setMindmap] = useState(null);\r\n  const [markdownText, setMarkdownText] = useState('');\r\n  const [copyMode, setCopyMode] = useState(false);\r\n\r\n  useEffect(() => {\r\n    fetchData();\r\n  }, [mindmapId]);\r\n\r\n  // サーバーからマインドマップ取得\r\n  const fetchData = async () => {\r\n    try {\r\n      const res = await axios.get(`${SERVER_URL}/api/mindmaps/${mindmapId}`);\r\n      setMindmap(res.data);\r\n    } catch (err) {\r\n      console.error(err);\r\n    }\r\n  };\r\n\r\n  // mindmap 取得後に番号付け & Markdown生成\r\n  useEffect(() => {\r\n    if (!mindmap) return;\r\n    const numberedNodes = buildNumberedTree(mindmap);\r\n    const md = convertToMarkdown(numberedNodes);\r\n    setMarkdownText(md);\r\n  }, [mindmap]);\r\n\r\n  /**\r\n   * ツリー構築 & 番号付け\r\n   * 1) ルートノード: インバウンドエッジが無いノード\r\n   * 2) 子ノード: edges で繋がっている中から \"from === parentId\" のものを作成順に探す\r\n   * 3) 再帰的に \"parentNumber.childIndex\" 形式で番号付け\r\n   * 4) 深さが 7 超える場合は無視\r\n   */\r\n  const buildNumberedTree = (mapData) => {\r\n    const { nodes, edges } = mapData;\r\n    if (!nodes || nodes.length === 0) return [];\r\n\r\n    // ノードID -> インバウンド数\r\n    const inboundCountMap = {};\r\n    nodes.forEach((node) => {\r\n      inboundCountMap[node.nodeId] = 0;\r\n    });\r\n    edges?.forEach((edge) => {\r\n      if (inboundCountMap[edge.to] != null) {\r\n        inboundCountMap[edge.to]++;\r\n      }\r\n    });\r\n\r\n    // ルートノード判定 (inboundCount=0 のノードが候補)\r\n    const rootNodes = nodes.filter((n) => inboundCountMap[n.nodeId] === 0);\r\n    // 複数ある場合は先頭をルートとする\r\n    const rootNode = rootNodes[0] || nodes[0];\r\n    if (!rootNode) return [];\r\n\r\n    // ノードID -> ノードオブジェクト\r\n    const nodeMap = {};\r\n    nodes.forEach((nd) => {\r\n      nodeMap[nd.nodeId] = nd;\r\n    });\r\n\r\n    // 親 -> 子ノードID のマップ（作成順に）\r\n    const childrenMap = {};\r\n    nodes.forEach((nd) => {\r\n      childrenMap[nd.nodeId] = [];\r\n    });\r\n    edges?.forEach((edge) => {\r\n      if (childrenMap[edge.from]) {\r\n        childrenMap[edge.from].push(edge.to);\r\n      }\r\n    });\r\n    // 作成順にソート（nodes 配列の並び順で）\r\n    Object.keys(childrenMap).forEach((key) => {\r\n      childrenMap[key].sort((a, b) => {\r\n        const idxA = nodes.findIndex((n) => n.nodeId === a);\r\n        const idxB = nodes.findIndex((n) => n.nodeId === b);\r\n        return idxA - idxB;\r\n      });\r\n    });\r\n\r\n    // 再帰的に番号を振りながらツリーをたどる\r\n    const result = [];\r\n    const dfs = (nodeId, numbering) => {\r\n      const depth = numbering.split('.').length;\r\n      if (depth > MAX_DEPTH) return;\r\n      const nodeObj = nodeMap[nodeId];\r\n      if (!nodeObj) return;\r\n      result.push({\r\n        numbering,\r\n        text: nodeObj.text || ''\r\n      });\r\n      const childs = childrenMap[nodeId] || [];\r\n      childs.forEach((childId, index) => {\r\n        const newNumber = `${numbering}.${index + 1}`;\r\n        dfs(childId, newNumber);\r\n      });\r\n    };\r\n    // ルートを \"1\" で開始\r\n    dfs(rootNode.nodeId, '1');\r\n    return result;\r\n  };\r\n\r\n  /**\r\n   * 番号付きツリーを Markdown の文字列に変換\r\n   * 見出しレベルは numbering のドット区切りの数\r\n   */\r\n  const convertToMarkdown = (numberedNodes) => {\r\n    let md = '';\r\n    numberedNodes.forEach((item) => {\r\n      const parts = item.numbering.split('.');\r\n      const level = parts.length;\r\n      md += `${'#'.repeat(level)} ${item.numbering}\\n`;\r\n      md += `${item.text}\\n\\n`;\r\n    });\r\n    return md.trim();\r\n  };\r\n\r\n  /**\r\n   * 「コピーモード」の挙動:\r\n   * セクション単位で（見出し行から次の見出し直前まで）hover した際に背景色を変え、\r\n   * クリックでそのセクション全体の Markdown テキストをクリップボードにコピーする\r\n   */\r\n  const handleCopySection = (sectionText) => {\r\n    navigator.clipboard.writeText(sectionText).then(() => {\r\n      alert('クリップボードにコピーしました');\r\n    });\r\n  };\r\n\r\n  /**\r\n   * Markdown テキストをセクションに分割し、レンダリング（renderCopy モードの場合はセクション全体に\r\n   * hover/click イベントを付与）\r\n   */\r\n  const renderMarkdownWithCopy = (md) => {\r\n    const lines = md.split('\\n');\r\n    const sections = [];\r\n    let currentSection = [];\r\n    lines.forEach((line) => {\r\n      if (line.startsWith('#')) {\r\n        if (currentSection.length > 0) {\r\n          sections.push(currentSection);\r\n        }\r\n        currentSection = [line];\r\n      } else {\r\n        currentSection.push(line);\r\n      }\r\n    });\r\n    if (currentSection.length > 0) {\r\n      sections.push(currentSection);\r\n    }\r\n    return sections.map((sectionLines, idx) => {\r\n      const sectionText = sectionLines.join('\\n');\r\n      if (!copyMode) {\r\n        // 通常はレンダリング済みの HTML として表示（Markdownが解釈される）\r\n        return (\r\n          <div\r\n            key={idx}\r\n            dangerouslySetInnerHTML={{ __html: marked.parse(sectionText, { breaks: true }) }}\r\n          />\r\n        );\r\n      } else {\r\n        // コピーモード：セクション全体に hover/click イベントを付与\r\n        return (\r\n          <div\r\n            key={idx}\r\n            style={{ cursor: 'pointer' }}\r\n            onMouseOver={(e) => {\r\n              e.currentTarget.style.backgroundColor = '#ffffa0';\r\n            }}\r\n            onMouseOut={(e) => {\r\n              e.currentTarget.style.backgroundColor = 'transparent';\r\n            }}\r\n            onClick={() => handleCopySection(sectionText)}\r\n            dangerouslySetInnerHTML={{ __html: marked.parse(sectionText, { breaks: true }) }}\r\n          />\r\n        );\r\n      }\r\n    });\r\n  };\r\n\r\n  if (!mindmap) {\r\n    return <div>読み込み中...</div>;\r\n  }\r\n\r\n  return (\r\n    <div style={{ position: 'relative', width: '100%', height: '100vh', margin: 0 }}>\r\n      {/* 固定ヘッダー */}\r\n      <div\r\n        style={{\r\n          position: 'fixed',\r\n          top: 0,\r\n          left: 0,\r\n          width: '100%',\r\n          height: 50,\r\n          background: '#ddd',\r\n          display: 'flex',\r\n          alignItems: 'center',\r\n          padding: '0 20px',\r\n          boxSizing: 'border-box',\r\n          zIndex: 10\r\n        }}\r\n      >\r\n        <h3 style={{ marginRight: 20 }}>{mindmap.title} - Export</h3>\r\n        <button onClick={() => setCopyMode(!copyMode)}>\r\n          {copyMode ? 'コピーモードOFF' : 'コピーモードON'}\r\n        </button>\r\n      </div>\r\n\r\n      {/* Markdown 表示部（スクロール可能） */}\r\n      <div style={{ marginTop: 60, padding: '0 20px' }}>\r\n        {renderMarkdownWithCopy(markdownText)}\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default ExportMarkdown;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}